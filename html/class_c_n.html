<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Option Pricing with the Crank Nicolson Method: CN Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="paris-saclay-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Option Pricing with the Crank Nicolson Method<span id="projectnumber">&#160;v24.1</span>
   </div>
   <div id="projectbrief">Nikolaou K., Spadafina F.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_c_n-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CN Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class performs the Crank Nicolson finite differencing scheme for pricing European and American Option, for non-constant risk free interest rate.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_n_8h_source.html">CN.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8566b92badf975e5087fef9aa921bc31" id="r_a8566b92badf975e5087fef9aa921bc31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8566b92badf975e5087fef9aa921bc31">CN</a> (std::string op, std::string type_, double s0, double k, std::vector&lt; std::pair&lt; double, double &gt; &gt; r_, double s_, int nx=100, int nt=100, double tf=1.0, double t0=0.0)</td></tr>
<tr class="memdesc:a8566b92badf975e5087fef9aa921bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of time steps.  <br /></td></tr>
<tr class="separator:a8566b92badf975e5087fef9aa921bc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ab66fef6263aae11fbd8f6934e482a" id="r_a30ab66fef6263aae11fbd8f6934e482a"><td class="memItemLeft" align="right" valign="top"><a id="a30ab66fef6263aae11fbd8f6934e482a" name="a30ab66fef6263aae11fbd8f6934e482a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~CN</b> ()</td></tr>
<tr class="memdesc:a30ab66fef6263aae11fbd8f6934e482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class. <br /></td></tr>
<tr class="separator:a30ab66fef6263aae11fbd8f6934e482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b03b1b8c3fec9240042cfe0811501" id="r_ae52b03b1b8c3fec9240042cfe0811501"><td class="memItemLeft" align="right" valign="top"><a id="ae52b03b1b8c3fec9240042cfe0811501" name="ae52b03b1b8c3fec9240042cfe0811501"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CN</b> (<a class="el" href="class_c_n.html">CN</a> &amp;b)</td></tr>
<tr class="memdesc:ae52b03b1b8c3fec9240042cfe0811501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor of the class. <br /></td></tr>
<tr class="separator:ae52b03b1b8c3fec9240042cfe0811501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36747db3f4e23e677bacf0de7043783e" id="r_a36747db3f4e23e677bacf0de7043783e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36747db3f4e23e677bacf0de7043783e">defineRate</a> (double dr_=0)</td></tr>
<tr class="memdesc:a36747db3f4e23e677bacf0de7043783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a vector of pairs from the constructor and linearly interpolates for the entire time span, creating a varying risk-free interest rate.  <br /></td></tr>
<tr class="separator:a36747db3f4e23e677bacf0de7043783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163821b9af89220dee256ed3888c57e5" id="r_a163821b9af89220dee256ed3888c57e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163821b9af89220dee256ed3888c57e5">solveTridiagonal</a> (const std::vector&lt; double &gt; &amp;lower, const std::vector&lt; double &gt; &amp;diag, const std::vector&lt; double &gt; &amp;upper, const std::vector&lt; double &gt; &amp;b, std::vector&lt; double &gt; &amp;result)</td></tr>
<tr class="memdesc:a163821b9af89220dee256ed3888c57e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a tridiagonal matrix using the Thomas Algorithm.  <br /></td></tr>
<tr class="separator:a163821b9af89220dee256ed3888c57e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c199ba3af3bdc998fb3c3f7c9b37792" id="r_a2c199ba3af3bdc998fb3c3f7c9b37792"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c199ba3af3bdc998fb3c3f7c9b37792">meanSecondElement</a> (const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2c199ba3af3bdc998fb3c3f7c9b37792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean of the second part of a vector of pairs.  <br /></td></tr>
<tr class="separator:a2c199ba3af3bdc998fb3c3f7c9b37792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874888515c7729a71a57ff5e0ff709ba" id="r_a874888515c7729a71a57ff5e0ff709ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a874888515c7729a71a57ff5e0ff709ba">solve</a> (double dP=0, double ds_=0, double dr_=0)</td></tr>
<tr class="memdesc:a874888515c7729a71a57ff5e0ff709ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Black Schole PDE using the Crank Nicholson finite differencing method.  <br /></td></tr>
<tr class="separator:a874888515c7729a71a57ff5e0ff709ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7e24e4fa0ffe3b64e662858d161d01" id="r_afa7e24e4fa0ffe3b64e662858d161d01"><td class="memItemLeft" align="right" valign="top"><a id="afa7e24e4fa0ffe3b64e662858d161d01" name="afa7e24e4fa0ffe3b64e662858d161d01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve_and_save</b> ()</td></tr>
<tr class="memdesc:afa7e24e4fa0ffe3b64e662858d161d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the solve function and saves the result on a .csv file. <br /></td></tr>
<tr class="separator:afa7e24e4fa0ffe3b64e662858d161d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fc9e231dfecbac928a68c567acd5ba" id="r_a83fc9e231dfecbac928a68c567acd5ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83fc9e231dfecbac928a68c567acd5ba">OptionPrice_At</a> (double t=0)</td></tr>
<tr class="memdesc:a83fc9e231dfecbac928a68c567acd5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option price at time t.  <br /></td></tr>
<tr class="separator:a83fc9e231dfecbac928a68c567acd5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de654b6f46a7b50d2bb36aeb7a0d20" id="r_ae2de654b6f46a7b50d2bb36aeb7a0d20"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2de654b6f46a7b50d2bb36aeb7a0d20">Delta_At</a> (double t=0, double dP=0.5)</td></tr>
<tr class="memdesc:ae2de654b6f46a7b50d2bb36aeb7a0d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Delta at time t. Uses central differencing.  <br /></td></tr>
<tr class="separator:ae2de654b6f46a7b50d2bb36aeb7a0d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a22d7ade61cf4c5449a2ade1e090ad" id="r_a62a22d7ade61cf4c5449a2ade1e090ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a22d7ade61cf4c5449a2ade1e090ad">Gamma_At</a> (double t=0, double dP=0.5)</td></tr>
<tr class="memdesc:a62a22d7ade61cf4c5449a2ade1e090ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Gamma at time t. Uses central differencing.  <br /></td></tr>
<tr class="separator:a62a22d7ade61cf4c5449a2ade1e090ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080d5432e1347013a21a9876968fa88e" id="r_a080d5432e1347013a21a9876968fa88e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080d5432e1347013a21a9876968fa88e">Rho_At</a> (double t=0, double dr_=0.01)</td></tr>
<tr class="memdesc:a080d5432e1347013a21a9876968fa88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Rho at time t. Uses central differencing.  <br /></td></tr>
<tr class="separator:a080d5432e1347013a21a9876968fa88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c261b0c1430762a67e5baf1883d58" id="r_a3c8c261b0c1430762a67e5baf1883d58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8c261b0c1430762a67e5baf1883d58">Vega_At</a> (double t=0, double ds_=0.1)</td></tr>
<tr class="memdesc:a3c8c261b0c1430762a67e5baf1883d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Vega at time t. Uses central differencing.  <br /></td></tr>
<tr class="separator:a3c8c261b0c1430762a67e5baf1883d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa406441378a991143824ec41e75e3868" id="r_aa406441378a991143824ec41e75e3868"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa406441378a991143824ec41e75e3868">Theta_At</a> (double t=0)</td></tr>
<tr class="memdesc:aa406441378a991143824ec41e75e3868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Theta at time t. Uses central differencing. It uses the Time Steps (Tf-T0)/Nt for differencing.  <br /></td></tr>
<tr class="separator:aa406441378a991143824ec41e75e3868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c76e9529ee2eba9d540694acfd7b9bb" id="r_a3c76e9529ee2eba9d540694acfd7b9bb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c76e9529ee2eba9d540694acfd7b9bb">normCdf</a> (double x)</td></tr>
<tr class="memdesc:a3c76e9529ee2eba9d540694acfd7b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cumulative Distribution Function(CDF) for a Standard Normal Distribution of double x.  <br /></td></tr>
<tr class="separator:a3c76e9529ee2eba9d540694acfd7b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef1dbc07c405300d447ed7de631fe09" id="r_a1ef1dbc07c405300d447ed7de631fe09"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef1dbc07c405300d447ed7de631fe09">trapezoidal</a> (const std::vector&lt; double &gt; &amp;f, double a, double b)</td></tr>
<tr class="memdesc:a1ef1dbc07c405300d447ed7de631fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the trapezoidal approach for approximating an integral.  <br /></td></tr>
<tr class="separator:a1ef1dbc07c405300d447ed7de631fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254417f9c348f3c915499b69809109f8" id="r_a254417f9c348f3c915499b69809109f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254417f9c348f3c915499b69809109f8">validate</a> ()</td></tr>
<tr class="memdesc:a254417f9c348f3c915499b69809109f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the Black Scholes explicit model to price the option.  <br /></td></tr>
<tr class="separator:a254417f9c348f3c915499b69809109f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae10d582303ee44b1ac21d0bcfda52" id="r_a23ae10d582303ee44b1ac21d0bcfda52"><td class="memItemLeft" align="right" valign="top"><a id="a23ae10d582303ee44b1ac21d0bcfda52" name="a23ae10d582303ee44b1ac21d0bcfda52"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>compare_eu_us_nc</b> ()</td></tr>
<tr class="memdesc:a23ae10d582303ee44b1ac21d0bcfda52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform time stepping for european call/put and american call/put to prove they are the same for r&gt;0/r&lt;0. We assume that the risk free interest rate remains strictly positive/negative for a call/put. <br /></td></tr>
<tr class="separator:a23ae10d582303ee44b1ac21d0bcfda52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee669acba88db151432cbd4a9dd824a" id="r_a6ee669acba88db151432cbd4a9dd824a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee669acba88db151432cbd4a9dd824a">delta</a> (double dP=0.5)</td></tr>
<tr class="memdesc:a6ee669acba88db151432cbd4a9dd824a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Delta. Uses central differencing.  <br /></td></tr>
<tr class="separator:a6ee669acba88db151432cbd4a9dd824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e919fc59d6e27eeeaf08758530ac4" id="r_a8e2e919fc59d6e27eeeaf08758530ac4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e2e919fc59d6e27eeeaf08758530ac4">gamma</a> (double dP=0.5)</td></tr>
<tr class="memdesc:a8e2e919fc59d6e27eeeaf08758530ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Gamma. Uses central differencing.  <br /></td></tr>
<tr class="separator:a8e2e919fc59d6e27eeeaf08758530ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec097efeeb5da1031f9ea456e34822" id="r_a8aec097efeeb5da1031f9ea456e34822"><td class="memItemLeft" align="right" valign="top"><a id="a8aec097efeeb5da1031f9ea456e34822" name="a8aec097efeeb5da1031f9ea456e34822"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>theta</b> ()</td></tr>
<tr class="memdesc:a8aec097efeeb5da1031f9ea456e34822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Theta. Uses forward differencing. <br /></td></tr>
<tr class="separator:a8aec097efeeb5da1031f9ea456e34822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b34c36803ce0769ac3bbe2fb3d0887" id="r_a93b34c36803ce0769ac3bbe2fb3d0887"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93b34c36803ce0769ac3bbe2fb3d0887">rho</a> (double dr=0.01)</td></tr>
<tr class="memdesc:a93b34c36803ce0769ac3bbe2fb3d0887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Rho. Uses central differencing.  <br /></td></tr>
<tr class="separator:a93b34c36803ce0769ac3bbe2fb3d0887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff38209c083f07a7c84ecea1925ec1fa" id="r_aff38209c083f07a7c84ecea1925ec1fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff38209c083f07a7c84ecea1925ec1fa">vega</a> (double dSigma=0.1)</td></tr>
<tr class="memdesc:aff38209c083f07a7c84ecea1925ec1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the computation's date option Vega. Uses central differencing.  <br /></td></tr>
<tr class="separator:aff38209c083f07a7c84ecea1925ec1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class performs the Crank Nicolson finite differencing scheme for pricing European and American Option, for non-constant risk free interest rate. </p>
<p>This class is able to price Vanilla Options with the Crank Nicolson finite differencing numerical method, for a non constant interest rate, using linear interpolation over the points in time given. It does for no dividents, meaning the American and european values shoudl be the same and can be compared to the Black Scholes explicit model. The class provides the ability to compare the two types of options, and validate performs using the explicit method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8566b92badf975e5087fef9aa921bc31" name="a8566b92badf975e5087fef9aa921bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8566b92badf975e5087fef9aa921bc31">&#9670;&#160;</a></span>CN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CN::CN </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>type_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>r_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of time steps. </p>
<p>Constructor for the class </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>String, The type of option, American or European </td></tr>
    <tr><td class="paramname">type_</td><td>String, The exercise type Call or Put </td></tr>
    <tr><td class="paramname">s0</td><td>Double, The underlying asset (Spot) price today </td></tr>
    <tr><td class="paramname">k</td><td>Double, The strike price </td></tr>
    <tr><td class="paramname">r_</td><td>A vector of pairs containing a double representing a date between T0 and Maturity, and a double representing the risk-free interest rate at that time. </td></tr>
    <tr><td class="paramname">s_</td><td>Double, The volatility of the underlying asset </td></tr>
    <tr><td class="paramname">nx</td><td>Integer for the spot grid points. Default price is 100. </td></tr>
    <tr><td class="paramname">nt</td><td>Integer for the time grid points. Default price is 100. </td></tr>
    <tr><td class="paramname">tf</td><td>Double, Maturity time. Default time is 1.0. </td></tr>
    <tr><td class="paramname">t0</td><td>Double, Computation time. Default time is 0.0 (today). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a36747db3f4e23e677bacf0de7043783e" name="a36747db3f4e23e677bacf0de7043783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36747db3f4e23e677bacf0de7043783e">&#9670;&#160;</a></span>defineRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::defineRate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dr_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a vector of pairs from the constructor and linearly interpolates for the entire time span, creating a varying risk-free interest rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr_</td><td>Double, represents a pertrubation in the interest rate. Used for deriving the Rho of the option, default value is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated vector with an interest rate for every time step </dd></dl>

</div>
</div>
<a id="a6ee669acba88db151432cbd4a9dd824a" name="a6ee669acba88db151432cbd4a9dd824a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee669acba88db151432cbd4a9dd824a">&#9670;&#160;</a></span>delta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; CN::delta </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Delta. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dP</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2de654b6f46a7b50d2bb36aeb7a0d20" name="ae2de654b6f46a7b50d2bb36aeb7a0d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2de654b6f46a7b50d2bb36aeb7a0d20">&#9670;&#160;</a></span>Delta_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::Delta_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Delta at time t. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step. Default Value is 0.0. </td></tr>
    <tr><td class="paramname">dP</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2e919fc59d6e27eeeaf08758530ac4" name="a8e2e919fc59d6e27eeeaf08758530ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2e919fc59d6e27eeeaf08758530ac4">&#9670;&#160;</a></span>gamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; CN::gamma </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Gamma. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dP</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62a22d7ade61cf4c5449a2ade1e090ad" name="a62a22d7ade61cf4c5449a2ade1e090ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a22d7ade61cf4c5449a2ade1e090ad">&#9670;&#160;</a></span>Gamma_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::Gamma_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Gamma at time t. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step </td></tr>
    <tr><td class="paramname">dP</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c199ba3af3bdc998fb3c3f7c9b37792" name="a2c199ba3af3bdc998fb3c3f7c9b37792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c199ba3af3bdc998fb3c3f7c9b37792">&#9670;&#160;</a></span>meanSecondElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CN::meanSecondElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean of the second part of a vector of pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of pairs containing doubles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Double, the arithmetic mean </dd></dl>

</div>
</div>
<a id="a3c76e9529ee2eba9d540694acfd7b9bb" name="a3c76e9529ee2eba9d540694acfd7b9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c76e9529ee2eba9d540694acfd7b9bb">&#9670;&#160;</a></span>normCdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CN::normCdf </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Cumulative Distribution Function(CDF) for a Standard Normal Distribution of double x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Double </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83fc9e231dfecbac928a68c567acd5ba" name="a83fc9e231dfecbac928a68c567acd5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fc9e231dfecbac928a68c567acd5ba">&#9670;&#160;</a></span>OptionPrice_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::OptionPrice_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option price at time t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93b34c36803ce0769ac3bbe2fb3d0887" name="a93b34c36803ce0769ac3bbe2fb3d0887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b34c36803ce0769ac3bbe2fb3d0887">&#9670;&#160;</a></span>rho()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; CN::rho </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.01</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Rho. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.01 (or 1%). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080d5432e1347013a21a9876968fa88e" name="a080d5432e1347013a21a9876968fa88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080d5432e1347013a21a9876968fa88e">&#9670;&#160;</a></span>Rho_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::Rho_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dr_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.01</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Rho at time t. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step </td></tr>
    <tr><td class="paramname">dr_</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.01 (or 1%). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a874888515c7729a71a57ff5e0ff709ba" name="a874888515c7729a71a57ff5e0ff709ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874888515c7729a71a57ff5e0ff709ba">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; CN::solve </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ds_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dr_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the Black Schole PDE using the Crank Nicholson finite differencing method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dP</td><td>Pertrubation in price, used for Delta computation </td></tr>
    <tr><td class="paramname">ds_</td><td>Pertrubation in volatility, used for Vega computation </td></tr>
    <tr><td class="paramname">dr_</td><td>Pertrubation in interest rate, passed to DefineRate, used for Rho computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors with the solution of the option pricing </dd></dl>

</div>
</div>
<a id="a163821b9af89220dee256ed3888c57e5" name="a163821b9af89220dee256ed3888c57e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163821b9af89220dee256ed3888c57e5">&#9670;&#160;</a></span>solveTridiagonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CN::solveTridiagonal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>diag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a tridiagonal matrix using the Thomas Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower</td><td>The lower diagonal </td></tr>
    <tr><td class="paramname">diag</td><td>The middle diagonal </td></tr>
    <tr><td class="paramname">upper</td><td>The upper diagonal </td></tr>
    <tr><td class="paramname">b</td><td>The right hand part vector </td></tr>
    <tr><td class="paramname">result</td><td>An empty vector which is populated with the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa406441378a991143824ec41e75e3868" name="aa406441378a991143824ec41e75e3868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa406441378a991143824ec41e75e3868">&#9670;&#160;</a></span>Theta_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::Theta_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Theta at time t. Uses central differencing. It uses the Time Steps (Tf-T0)/Nt for differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step. Default Value is 0.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ef1dbc07c405300d447ed7de631fe09" name="a1ef1dbc07c405300d447ed7de631fe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef1dbc07c405300d447ed7de631fe09">&#9670;&#160;</a></span>trapezoidal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CN::trapezoidal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the trapezoidal approach for approximating an integral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Vector of arbitary length, the function over which to integrate </td></tr>
    <tr><td class="paramname">a</td><td>Double, lower limit of integration </td></tr>
    <tr><td class="paramname">b</td><td>Double, upper limit if integration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a254417f9c348f3c915499b69809109f8" name="a254417f9c348f3c915499b69809109f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254417f9c348f3c915499b69809109f8">&#9670;&#160;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CN::validate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the Black Scholes explicit model to price the option. </p>
<p>Due to the lemma that states that how an european and an american option call/put with no dividents are equal when r is positive/negative, we just compute the european option using the black-scholes model(you can confirm the lemma by suing method compare us_and_eu()). </p>

</div>
</div>
<a id="aff38209c083f07a7c84ecea1925ec1fa" name="aff38209c083f07a7c84ecea1925ec1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff38209c083f07a7c84ecea1925ec1fa">&#9670;&#160;</a></span>vega()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; CN::vega </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dSigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Vega. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dSigma</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c8c261b0c1430762a67e5baf1883d58" name="a3c8c261b0c1430762a67e5baf1883d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c261b0c1430762a67e5baf1883d58">&#9670;&#160;</a></span>Vega_At()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; CN::Vega_At </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ds_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the computation's date option Vega at time t. Uses central differencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Double, time to extract the target. Must be between T0 and Tf. It is rounded to the index corresponding to the nearest time step </td></tr>
    <tr><td class="paramname">ds_</td><td>Double, the pertrubation for the differencing scheme. Default Value is 0.1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_n_8h_source.html">CN.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
